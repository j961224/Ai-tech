# 1. 8월2일 공부한 것 정리!

## 1-1. Basic computer class for newbies

### 1. 컴퓨터 OS

: Operation System으로 운영체제이다.

* 우리의 프로그램이 동작할 수 있는 구동 환경이다.


### 2. 파일 시스템

: OS에서 파일을 저장하는 트리구조 저장체계이다!

* 경로 - 컴퓨터 파일의 고유한 위치로 트리구조상 노드의 연결을 뜻한다.
  * 절대 경로 - 루트 디렉토리부터 파일위치까지의 경로를 말한다.
  * 상대 경로 - 현재 있는 디렉토리로부터 타깃 파일까지의 경로를 말한다.

* 디렉토리 - 폴더 또는 디렉토리라 불리며 파일 시스템안에서 파일과 다른 하부 디렉토리들로 구성되어 있다.


### 3. 터미널

: 마우스가 아닌 키보드로 명령을 입력하여 프로그램을 실행한다.

* **CLI**
 
 : GUI와 달리 text를 사용하여 컴퓨터에 명령을 입력하는 인터페이스 체계이다.

* Terminal 시작하기

  : 윈도우 -> 윈도우키+R => CMD입력
  
  ![cmdd](https://user-images.githubusercontent.com/59636424/127859187-6974e8fd-9c0f-4063-9784-304b045973fc.PNG)

* 기본 명령어

| CMD 명령어 | shell 명령어 | 설명 |
|------------|-------------|-------|
| CD | CD | 현재 디렉토리 이름을 보여준다.|
| CLS | clear | CMD에 띄운 것을 모두 지운다. |
| COPY | cp | 하나 이상의 파일을 다른 곳으로 복사한다. |
| DEL | rm | 하나 이상의 파일을 지운다. |
| DIR | ls | 디렉토리에 존재하는 파일과 그에 대한 하위 디렉토리 목록을 보여준다.|


## 1-2. 파이썬 개요

* 특징
 * 독립적
   
   : 운영체제 상관없이 돌아가는 언어
 
 * 인터프리터 언어
   
   : 파이썬 문법으로 만들어진 코드를 인터프리터로 운영체제에 맞게 번역해 바로 실행할 수 있게 지원한다.
   
    **인터프리터 vs 컴파일러**
    
    : **컴파일러**는 소스코드를 기계어로 먼저 번역하며 해당 플랫폼에 최적화되어 프로그램을 실행하는 반면 **인터프리터**는 별도의 번역과정 없이 소스코드를 실행시점에 해석하며 컴퓨터가 처리
    
    : **컴파일러**는 실행속도가 빠르지만 한 번의 많은 기억장소 필요로 하고 **인터프리터**는 간단히 작성하되, 메모리가 적게 필요로 하고 단점은 실행속도가 느리다.

 * 객체 지향 언어
 
   : 실행 순서가 아닌 단위 모듈(객체) 중심으로 프로그램을 작성


 * 동적 타이핑 언어
 
   : 프로그램이 실행하는 시점에 프로그램이 사용해야할 데이터에 대한 타입을 결정
 
 * 이해하기 쉬운 문법이고 다양한 라이브러리를 지원한다.


## 2-1. Variables

 : 가장 기초적인 프로그래밍 문법 개념이다.
 
* 변수란?

  : 프로그래밍에서는 변수는 값을 저장하는 장소로 변수는 **메모리 주소**를 가지고 있고 변수에 들어가는 값은 **메모리 주소**에 할당됨
  
  => 쉽게 말하면 특정한 값을 저장한다. (메모리 특정영역에 물리적인 공간에 할당 됨)

* 변수명은 의미 있는 단어로 표기하는 것이 좋고 **대소문자가 구분**되고 **예약어를 사용하지 않는다.**

* **Dynamic Typing**

 : 코드 실행시점에 데이터의 type을 결정하는 방법이다.

* list

~~~
a=[1,2,3]
b=a[:] # 이 순간에 복사를 하게되어 같은 공간을 가르키는 것이 아니라 카피하는 것이다!
print(a) #[1,2,3]
print(b) #[1,2,3]
print(a==b) #True
~~~

하지만 2차원에서는 그냥 copy가 아닌 deepcopy를 사용해야한다!

~~~
import copy
a=[[1,2,3],[2,3,4]]
b=copy.deepcopy(a)
print(a) # [[1,2,3],[2,3,4]]
print(b) # [[1,2,3],[2,3,4]]
print(a==b) # True
~~~


## AI math 1강 - 벡터가 뭐에요?

* **벡터란?**: 공간에서 한 점을 나타낸다.
 
  => 숫자를 원소로 가지는 리스트 또는 배열!

* 벡터의 노름(norm): 원점에서부터 거리를 말한다.

* L1 norm: 각 성분의 변화량의 절대값을 모두 더한다.

* **L2 norm**: 유클리드 거리를 계산한다.

![norm](https://user-images.githubusercontent.com/59636424/127865695-68d914bb-4e6d-40a7-9a39-92060dd927ee.PNG)


* 제 2 코사인 법칙에 의해 두 벡터 사이의 각도를 계산할 수 있다.

![cos](https://user-images.githubusercontent.com/59636424/127866495-01d856d6-2062-4a92-85fe-d896149d2f72.PNG)


* 내적: 두 벡터들의 성분곱들을 다 더해주는 것

  -> 내적은 정사영된 벡터의 길이와 연관이 있다.

![내적](https://user-images.githubusercontent.com/59636424/127866765-51e3e1ad-f85d-4341-addf-302ba2ebde90.PNG)


## AI math 2강 - 행렬이 뭐에요?

: 행렬은 벡터를 원소로 가지는 2차원 배열이다.

* 전치행렬: 행과 열의 인덱스를 바꾼다.

* np.inner로 i번째 행벡터와 j번째 행벡터 사이의 내적이 가능하다!

* 행를의 연산을 거꾸로 되돌리는 행렬을 **역행렬**이라 하며 np.linalg.inv로 구할 수 있다.

* **무어-펜로즈 역행렬**

  : 행과 열의 숫자가 달라도 사용할 수 있는 것이 무어펜로즈 역행렬이다.(A+)
  
  ![역행렬](https://user-images.githubusercontent.com/59636424/127867478-5c9b9d09-66c5-481f-bcd9-c7101081f02f.PNG)
  
  : n은 행의 수, m은 열의 수를 의미하며 첫 줄은 행의 개수가 클 때, 역행렬을 구하는 방식이고 둘째 줄은 열의 개수가 클 때, 역행렬을 구하는 방식이다.
  
  => 이러한 유사 역행렬을 구할 수 있다.


## AI math 3강 경사하강법

* 미분: 변수의 움직임에 따른 함수값의 변화를 측정하기 위한 도구이다.
  
  -> 최적화에서 제일 많이 사용하는 기법

### **경사상승법**

![경사상승법](https://user-images.githubusercontent.com/59636424/127868412-204e78dc-31ff-43fd-81e2-cbf969758b58.PNG)

: 미분값을 더하면 경사상승법이라 하며 함수의 **극대값**의 위치를 구한다.

### **경사하강법**

![경사하강법](https://user-images.githubusercontent.com/59636424/127868536-af9bb073-67e0-4e93-8006-23f546a4dc89.PNG)

: 미분값을 빼면 경사하강법이라 하며 함수의 **극소값**의 위치를 구한다.


### 편미분 : 다변수 함수의 경우에 사용된다.

![ㅋㅋㅋ](https://user-images.githubusercontent.com/59636424/127868816-026dc9b9-af8e-4f11-89ab-8d469e874f62.PNG)

: **그레디언트 벡터**(수직선이 아닌 D차원 공간에 벡터에 적용)로 극대점과 극소점을 알 수 있으므로 경사하강법과 경사상승법에 사용가능하다.

=> 최적화가 가능하다.


-> 선형모델이 아닌 다른 방식의 모델도 경사하강법으로 최적화할 수 있다!

-> 그러기 위해서는 목적식을 최소화 해야한다!(B)

![목적식](https://user-images.githubusercontent.com/59636424/127870434-62724bef-b666-4445-b383-bb4f1fcff3ca.PNG)

-> 그러기 위해서는 그레디언트 벡터를 구해야한다!

![백터값](https://user-images.githubusercontent.com/59636424/127871168-3753726f-fbe8-462d-aae2-4a539432ceaf.PNG)

=> 여기서 사용되는 l2 norm은 n개를 사용하니 평균값을 취하기 위해 **1/n을 해주고 제곱근을 해줘야한다!**

=> 아래 수식은 Bk를 미분한 결과이다.(분자는 y-Xb와 X 전체 행렬에 k번째 열 벡터를 곱해준 것)

![실제경사하강법](https://user-images.githubusercontent.com/59636424/127871110-a0f97bf9-d53d-49fb-a3dc-a078aed780fb.PNG)

=> 위의 경사하강법 알고리즘은 목적식을 최소화하는 B를 구하는 방법이다.(위에서 구한 gradient vector를 빼준다.)




### **SGD(확률적 경사하강법)**

: 확률적 경사하강법으로 데이터 1개나 일부 이용하여 업데이트를 한다.  

=> 비선형회귀 문제의 경우 목적식이 **볼록하지 않을 경우가 있어 수렴이 항상 보장되지 않으므로** SGD를 이용해 최적화하려는 목적이 있다!

=> 연산 지원을 좀 더 효율적으로 활용하는데 도움이 된다!


### **미니 배치 연산**

![증가](https://user-images.githubusercontent.com/59636424/127872724-c0ffdb04-bd7c-4bb2-84d0-3317c337415a.PNG)

: 확률적 경사하강법은 미니배치를 가지고 그레디언트를 계산하므로 전체 목적식이랑은 살짝 다르지만 유사하다!

-> 미니배치는 확률적으로 계산하므로 위의 사진과 같이 목적식 모양이 바뀐다.

![SGDD](https://user-images.githubusercontent.com/59636424/127873008-18ac4d1a-c6e8-4d41-864d-4b5cf303bdd6.PNG)

: SGD는 경사하강법보다 머신러닝 학습에 더 효율적이다!

=> 하지만 랜덤하여 추출한 일부 데이터를 사용하므로 **학습 중간 과정에서 결과의 진폭이 크고 불안정하지만 속도가 매우 빠르다.**

=> 이러한 단점을 보완하기 위해 나온 방법이 **미니 배치**를 이용한 방법으므로, **확률적 경사하강법의 노이즈를 줄이면서** 전체 배치보다 더 효율적이다!


* 각 배치 방법 비교

![증가](https://user-images.githubusercontent.com/59636424/127873947-c8305673-f792-4edf-88dc-07a9ff44bce3.PNG)

|방법|설명|
|----|----|
|Batch| 모든 데이터를 활용하여 부드럽게 수렴하지만 시간이 다소 소요|
|확률적 경사하강법| 데이터를 1개씩 추출해서 처리해보고 이를 모든 데이터에 적용|
|미니 배치| 전체 학습 데이터를 배치 사이즈로 나누어 순차적으로 진행 -> Batch보다 빠르고 SGD보다 낮은 오차율을 가짐|

(출처: https://go-hard.tistory.com/11)


# 2. 8월2일 피어세션 정리!

## 2-1. 이번주 학습은 권장 학습 계획표 따라하기

* 8/2 (월)

  * Python: 필수과제 1,2,3
  * AI Math: 필수퀴즈 1~4강

* 8/3 (화) 

  * Python: 필수과제 4,5
  * AI Math: 필수퀴즈 5~6강

* 8/4 (수)

  * Python: 선택과제 1,2,3
  * AI Math: 필수퀴즈: 7~9강

* 8/5 (목)

  * AI Math: 필수퀴즈: 10강

## 2-2. 그라운드 룰

~~~
모더레이터는 매일 번갈아가면서

순서 : 이홍규 - 변자민 - 서현범 - 정유석 - 이상은 - 박상하

5분 지각하면 장기자랑

피어세션 10~20분 전에 git에 공부한 내용 / 공유할 내용 올리기
~~~

# 3. 과제 수행 과정 / 결과물 정리

## 필수 과제 1번(Basic Math)

: 이 과제는 list와 변수 사용법을 학습하는 과제였습니다. 그래서 numpy를 이용해 max, min, mean, median을 이용하여 풀 수 있는 할 만 했던 과제였습니다.

## 필수 과제 2번(Tet Processing 1)

: string을 다루고 normalize, 정규화, join을 사용해야되는 과제였습니다. string을 받아 lower로 소문자화시켜 띄어쓰기 기준으로 잘라 배열에 넣고 그것을 join을 통해 string을 받아 return하는 함수를 구현했습니다. 그리고 다른 함수는 정규화 re를 통해 특정 알파벳을 제거하여 return 하는 함수를 구현했다면 테스트 케이스를 통과할 수 있었습니다.

## 필수 과제 3번(Text Processing 2)

: 이 과제는 2번과 마찬가지로 string을 다루는 문제였습니다. string에서 숫자만 추출하여 영어 단어로 변환하는 함수는 정규화 re를 이용해 0~9가 아닌 것은 없얘고 각 숫자마다 해당하는 영어와 매칭한 dictionary로 join을 통해 변환된 영어 단어를 string으로 만들어 return 했습니다. underscore를 camelscore로 변환하는 함수는 underscore 기준으로 split을 통해 잘랐습니다. 그 자른 배열을 하나씩 호출해 첫문자는 대문자화 및 나머지 소문자화 등으로 string을 만들어 return 했습니다.

# 4. 학습 회고

: 첫 수업이기도 해서 첫 수업부터 팀으로 뭔가를 진행하는 것이 부담됐습니다. 그래도 어색해도 부스트캠프에서 주어진 임무로 차근차근 분위기를 풀며 피어세션 규칙을 정할 수 있었습니다. 그리고 첫 주는 강의가 너무 많고 수학 부분도 많아 할 것이 많지만 어떻게든 따라가보려합니다!
